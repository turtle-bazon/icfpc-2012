
(in-package :lambda-lifter)

(defun in-range-p (metadata x y)
  (with-meta-bind (metadata width height)
    (and (>= x 1)
	 (>= y 1)
	 (<= x width)
	 (<= y height))))

(defmacro rock-move-values (world objects path metadata rx ry rx-new ry-new rock-type fall object-under &optional (non-map-update nil))
  `(values (lambda (x y)
	     (cond ((and (= x ,rx)
			 (= y ,ry))
		    nil)
		   ((and (= x ,rx-new)
			 (= y ,ry-new))
		    ,(if fall
			 `(if (and (eq ,rock-type :horock) ,object-under)
			      :lambda
			      ,rock-type)
			 rock-type))
		   (t (funcall ,world x y))))
	   (lambda (type)
	     (cond ((eq type ,rock-type) (cons (complex ,rx-new ,ry-new)
					       (remove (complex ,rx ,ry) (funcall ,objects ,rock-type))))
		   ((eq type :injury) (if ,non-map-update
					  nil
					  (eq ,object-under :robot)))
		   (t (funcall ,objects type))))
	   ,path
	   ,metadata))

(defun rock-fall (iworld imetadata rx ry)
  (lambda (world objects path metadata)
    (let* ((rx-under rx)
	   (ry-under (- ry 1))
	   (rx-new-under rx-under)
	   (ry-new-under (- ry-under 1)))
      (when (and (in-range-p imetadata rx-under ry-under)
		 (eq nil (funcall iworld rx-under ry-under)))
	(rock-move-values world objects path metadata rx ry rx-under ry-under
	    (funcall iworld rx ry) t
	    (when (in-range-p imetadata rx-new-under ry-new-under)
	      (funcall iworld rx-new-under ry-new-under)))))))

(defun rock-slide-right (iworld imetadata rx ry)
  (lambda (world objects path metadata)
    (let* ((rx-under rx)
	   (ry-under (- ry 1))
	   (rx-right (+ rx 1))
	   (ry-right ry)
	   (rx-right-under (+ rx 1))
	   (ry-right-under (- ry 1))
	   (rx-new-under rx-right-under)
	   (ry-new-under (- ry-right-under 1)))
      (when (and (in-range-p imetadata rx-right-under ry-right-under)
		 (member (funcall iworld rx-under ry-under) '(:rock :horock :lambda))
		 (eq nil (funcall iworld rx-right ry-right))
		 (eq nil (funcall iworld rx-right-under ry-right-under)))
	(rock-move-values world objects path metadata rx ry rx-right-under ry-right-under
	    (funcall iworld rx ry) t
	    (when (in-range-p imetadata rx-new-under ry-new-under)
	      (funcall iworld rx-new-under ry-new-under)))))))

(defun rock-slide-left (iworld imetadata rx ry)
  (lambda (world objects path metadata)
    (let* ((rx-under rx)
	   (ry-under (- ry 1))
	   (rx-right (+ rx 1))
	   (ry-right ry)
	   (rx-right-under (+ rx 1))
	   (ry-right-under (- ry 1))
	   (rx-left (- rx 1))
	   (ry-left ry)
	   (rx-left-under (- rx 1))
	   (ry-left-under (- ry 1))
	   (rx-new-under rx-left-under)
	   (ry-new-under (- ry-left-under 1)))
      (when (and (in-range-p imetadata rx-left-under ry-left-under)
		 (in-range-p imetadata rx-right-under ry-right-under)
		 (member (funcall iworld rx-under ry-under) '(:rock :horock))
		 (not (eq nil (funcall iworld rx-right ry-right)))
		 (not (eq nil (funcall iworld rx-right-under ry-right-under)))
		 (eq nil (funcall iworld rx-left ry-left))
		 (eq nil (funcall iworld rx-left-under ry-left-under)))
	(rock-move-values world objects path metadata rx ry rx-left-under ry-left-under
	    (funcall iworld rx ry) t
	    (when (in-range-p imetadata rx-new-under ry-new-under)
	      (funcall iworld rx-new-under ry-new-under)))))))

(defun rock-push-left (rx ry)
  (lambda (world objects path metadata)
    (let ((rx-left (- rx 1))
	  (ry-left ry))
      (when (and (in-range-p metadata rx-left ry-left)
		 (eq nil (funcall world rx-left ry-left)))
	(rock-move-values world objects path metadata rx ry rx-left ry-left
	    (funcall world rx ry) nil nil t)))))

(defun rock-push-right (rx ry)
  (lambda (world objects path metadata)
    (let ((rx-right (+ rx 1))
	  (ry-right ry))
      (when (and (in-range-p metadata rx-right ry-right)
		 (eq nil (funcall world rx-right ry-right)))
	(rock-move-values world objects path metadata rx ry rx-right ry-right
	    (funcall world rx ry) nil nil t)))))

(defun rock-can-be-pushed-left (world metadata rx ry)
  (let ((rx-left (- rx 1))
	(ry-left ry))
    (and (in-range-p metadata rx-left ry-left)
	 (eq nil (funcall world rx-left ry-left)))))

(defun rock-can-be-pushed-right (world metadata rx ry)
  (let ((rx-right (+ rx 1))
	(ry-right ry))
    (and (in-range-p metadata rx-right ry-right)
	 (eq nil (funcall world rx-right ry-right)))))

(defun make-m-v-or (&rest clauses)
  (lambda (world objects path metadata)
    (iter (for clause in clauses)
          (multiple-value-bind (world objects path metadata)
              (funcall clause world objects path metadata)
            (when world
              (return (values world objects path metadata))))
          (finally (return (values world objects path metadata))))))            

(defun rock-move (iworld imetadata rx ry)
  (make-m-v-or (rock-fall iworld imetadata rx ry)
               (rock-slide-right iworld imetadata rx ry)
               (rock-slide-left iworld imetadata rx ry)))

(defun rocks-move (world objects path metadata)
  (let ((world~ world)
	(objects~ objects)
	(path~ path)
	(metadata~ metadata))
    (with-meta-bind (metadata width)
      (iter (for rock-coord in (sort (append (funcall objects :rock)
					     (funcall objects :horock)) #'<
				     :key (lambda (c) (+ (realpart c) (* (imagpart c) width)))))
	(multiple-value-setq (world~ objects~ path~ metadata~)
	  (funcall (rock-move world metadata (realpart rock-coord) (imagpart rock-coord))
		   world~ objects~ path~ metadata~))))
    (values world~ objects~ path~ metadata~)))
